<!doctype html><html><head><meta charset="utf-8"><title>5acrostih Analysis</title>
<style>body{font-family:Georgia,serif;max-width:900px;margin:40px auto;line-height:1.6}
pre{background:#f6f8fa;padding:12px;overflow:auto;border:1px solid #e1e4e8}
code{font-family:ui-monospace,Consolas,monospace}
h1,h2,h3{font-family:Cambria,Georgia,serif}
hr{border:none;border-top:1px solid #ccc;margin:2em 0}
ul{margin-left:1.2em}
a{color:inherit;text-decoration:underline}
</style></head><body>
<h1>5acrostih (A–H): analiză tehnică și comentarii didactice</h1>
<p></p>
<p>_Generat: 2025-10-13T14:11:20_</p>
<p></p>
<h2>Context</h2>
<p>Acest set de scripturi demonstrează construirea unui **acrostih** (șir format din inițialele cuvintelor) în JavaScript/Node.js. Variantele arată stiluri expresive (`map`→`join`), **filtrare de stopwords**, tokenizare **din text liber** cu expresii regulate, **majuscule**, o **funcție pură** reutilizabilă și un mic **CLI**. Scopul didactic: practică pe procesare de șiruri, expresii regulate, imutabilitatea colecțiilor și ergonomia CLI.</p>
<p></p>
<h3>5acrostihA.js</h3>
<p>**Varianta A — pas‑cu‑pas (intermediar).** Expune vectorul cu inițiale și, opțional, concatenarea în șir — util didactic pentru a vedea etapele.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map, Array.prototype.join.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `5`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihA.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Acrostih: extrage prima literă din fiecare cuvânt și formează un nou șir.
 * Explicație:
 *   - folosim `map` pentru a extrage prima literă a fiecărui cuvânt
 *   - rezultatul este un array cu inițialele cuvintelor
 *   - folosim `join` pentru a concatena inițialele într-un singur șir
 * Poate fi util pentru a genera acronime sau coduri scurte (ca parte dintr-o aplicație mai mare):
 *   - generarea de coduri unice pentru elemente (ex: coduri de produse, etichete)
 *   - crearea de acronime pentru titluri sau denumiri lungi
 *   - generarea de identificatori (tip UUID) pentru utilizatori sau entități
 *   - in combinatie cu baze de date sau sisteme de autentificare
 */


const words = [&quot;the&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog&quot;];

// 1) map -&gt; extragem prima literă a fiecărui cuvânt
const initialsArray = words.map((w) =&gt; w[0]);      // [&quot;t&quot;,&quot;q&quot;,&quot;b&quot;,&quot;f&quot;,&quot;j&quot;,&quot;o&quot;,&quot;t&quot;,&quot;l&quot;,&quot;d&quot;]
console.log(initialsArray);

// 2) (opțional) join -&gt; un singur șir
const acrostic = initialsArray.join(&quot;&quot;);           // &quot;tqbfjotld&quot;
console.log(acrostic);

// =&gt; &quot;tqbfjotld&quot;
</code></pre>
<p></p>
<h3>5acrostihB.js</h3>
<p>**Varianta B — concisă (`map` + `join`).** Transformarea într‑un singur *pipeline* (mai succintă, aceeași complexitate).</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map, Array.prototype.join.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `3`, complexitate ciclomatică (aprox.) ≈ `2`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihB.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/** Varianta B — concisă, cu `map` + `join`
* Deosebirile dintre 5acrostihA.js și 5acrostihB.js sunt minore,
* dar suficiente pentru a justifica existența ambelor variante în demo-uri didactice.
* Deosebiri:
*    1) în 5acrostihA.js se face pas‑cu‑pas (intermediar), iar aici totul într‑un singur pas
*    2) în 5acrostihA.js se afișează inițialele ca array, apoi ca șir; aici doar ca șir
* La ce ajută?
*    - arată flexibilitatea lui `map` și `join`
*    - arată că există mai multe moduri de a rezolva aceeași problemă
*/




const words = [&quot;the&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog&quot;];

const acrostic = words.map((w) =&gt; w[0]).join(&quot;&quot;);
console.log(acrostic); // &quot;tqbfjotld&quot;

// =&gt; &quot;tqbfjotld&quot;
</code></pre>
<p></p>
<h3>5acrostihC.js</h3>
<p>**Varianta C — inițiale majuscule.** Aplică `toUpperCase()` pe `w[0]` înainte de `join`.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map, Array.prototype.join.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `0`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihC.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/** Varianta C — cu inițiale litere mari */

const words = [&quot;the&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog&quot;];

const acrosticUpper = words
  .map((w) =&gt; w[0].toUpperCase())
  .join(&quot;&quot;);
console.log(acrosticUpper); 


// =&gt; &quot;TQBFJOTLD&quot;
</code></pre>
<p></p>
<h3>5acrostihD.js</h3>
<p>**Varianta D — fără cuvinte de legătură.** Elimină *stopwords* cu un `Set` pentru căutare `O(1)` amortizat.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map, Array.prototype.filter, Array.prototype.join, Set (stopwords).</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `7`, complexitate ciclomatică (aprox.) ≈ `2`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihD.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/** Varianta D — fără cuvinte de legătură 
 *  Poate fi util pentru acronime (ex. NATO, UNESCO, etc.)
 *  Pot fi extinse cu alte cuvinte de legătură (ex. în, și, cu, de, la, pe, pentru, etc.)
 *  Sau chiar cu semne de punctuație (ex. ,, ., !, ?, ;, :, -, _, etc.)
*/



const words = [&quot;the&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog&quot;];
const stopwords = new Set([&quot;the&quot;,&quot;a&quot;,&quot;an&quot;]);

const acrosticNoStops = words
  .filter((w) =&gt; !stopwords.has(w.toLowerCase()))
  .map((w) =&gt; w[0])
  .join(&quot;&quot;);

console.log(acrosticNoStops); 
// =&gt;  &quot;qbfjotld&quot;
</code></pre>
<p></p>
<h3>5acrostihE.js</h3>
<p>**Varianta E — din text liber.** Tokenizare cu regex `split(/[^A-Za-z]+/)`; îndepărtează tokenii goi şi mizează pe litere ASCII.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map, Array.prototype.filter, Array.prototype.join.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `7`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihE.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
// Varianta E se deosebeste de D prin faptul ca extrage cuvintele dintr-un text liber, nu dintr-un array predefinit
/** Varianta E — din text liber, fără cuvinte de legătură
 * Explicație:
 *   - /[^A-Za-z]+/: expresie regulată care găsește orice secvență de caractere care nu sunt litere
 */

const raw = &quot;the quick brown fox, jumps over the 33 lazy dogs&quot;;
const words = raw
  .split(/[^A-Za-z]+/)           // separăm prin orice nu‑e literă
  .map((w) =&gt; w.trim())
  .filter((w) =&gt; w.length &gt; 0);

const acrostic = words.map((w) =&gt; w[0]).join(&quot;&quot;);
console.log(acrostic); 

// =&gt; &quot;tqbfjotld&quot;
</code></pre>
<p></p>
<h3>5acrostihF.js</h3>
<p>**Varianta F — funcție pură.** `acrosticFromWords(words)` separă clar calculul de IO — ideal pentru testare.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), funcții clasice (ES5), Array.prototype.map, Array.prototype.join.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `5`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihF.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Funcție pură: primește o listă de cuvinte și întoarce acrostihul.
 */
function acrosticFromWords(words) {
  return words.map((w) =&gt; w[0]).join(&quot;&quot;);
}

const words = [&quot;the&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog&quot;];
console.log(acrosticFromWords(words));

// =&gt; &quot;tqbfjotld&quot;
</code></pre>
<p></p>
<h3>5acrostihG.js</h3>
<p>**Varianta G — CLI.** Parametri: `--text=&quot;...&quot;` sau `--words=&quot;a,b,c&quot;`; parsează intrarea şi calculează acrostihul.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), funcții clasice (ES5), Array.prototype.map, Array.prototype.filter, Array.prototype.join, CLI Node.js.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `25`, complexitate ciclomatică (aprox.) ≈ `8`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihG.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Utilizare:
 *   node 5acrostihG.js --text=&quot;the quick brown fox jumps over the lazy dog&quot;
 *   node 5acrostihG.js --words=&quot;the,quick,brown,fox,jumps,over,the,lazy,dog&quot;
 */

function parseArgs(argv) {
  const args = {};
  for (let i = 2; i &lt; argv.length; i++) {
    const [k, v] = argv[i].split(&quot;=&quot;);
    if (k &amp;&amp; k.startsWith(&quot;--&quot;)) args[k.slice(2)] = v ?? &quot;&quot;;
  }
  return args;
}

const args = parseArgs(process.argv);

let words = [];
if (args.text) {
  words = String(args.text)
    .split(/[^A-Za-z]+/)
    .map((w) =&gt; w.trim())
    .filter((w) =&gt; w.length &gt; 0);
} else if (args.words) {
  words = String(args.words)
    .split(&quot;,&quot;)
    .map((w) =&gt; w.trim())
    .filter((w) =&gt; w.length &gt; 0);
} else {
  // fallback (exemplul canonic)
  words = [&quot;the&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog&quot;];
}

const acrostic = words.map((w) =&gt; w[0]).join(&quot;&quot;);
console.log(acrostic);
</code></pre>
<p></p>
<h3>5acrostihH.js</h3>
<p>**Varianta H — minimală (2 linii).** Evidenţiază expresivitatea `map`→`join` (didactic).</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map, Array.prototype.join.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `2`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** pentru un text de lungime `T` și `n` cuvinte, extragerea inițialelor este `O(T)` pentru tokenizare (sau `O(n)` dacă tabloul de cuvinte e deja dat) și `O(n)` pentru mapare/join; spațiu `O(n)` pentru rezultatul acrostihului.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(w =&gt; w[0])` extrage **prima literă** din fiecare cuvânt; `join(&quot;&quot;)` concatenează într‑un singur șir.</li>
<li>`filter` se folosește fie pentru a elimina cuvinte de legătură (*stopwords*), fie pentru a curăța tokeni goi după `split`.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 5acrostihH.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Varianta H — doar din doua linii de cod
 * Funcție care primește un array de cuvinte și returnează acronimul    
 * Explicație:
 *   - `words.map((w) =&gt; w[0])`: creează un nou array cu prima literă din fiecare cuvânt
 *   - `.join(&quot;&quot;)`: unește literele într-un singur șir, fără spații între ele
 */

const words = [&quot;the&quot;,&quot;quick&quot;,&quot;brown&quot;,&quot;fox&quot;,&quot;jumps&quot;,&quot;over&quot;,&quot;the&quot;,&quot;lazy&quot;,&quot;dog&quot;];
console.log(words.map((w) =&gt; w[0]).join(&quot;&quot;)); 

// =&gt; &quot;tqbfjotld&quot;
</code></pre>
<p></p>
<hr/>
<h2>Discuție transversală</h2>
<ul>
<li>**Tokenizare.** `split(/[^A-Za-z]+/)` este un model simplu pentru ASCII; pentru suport internațional (diacritice), preferați **Unicode property escapes** (vezi variațiunea I).</li>
<li>**Stopwords.** `Set` oferă test de apartenență eficient; *normalizarea* (`toLowerCase`, NFD/diacritice) este utilă în limbi cu diacritice (vezi variațiunea J).</li>
<li>**Imutabilitate.** `map`/`filter` creează tablouri noi (nu modifică sursa) — ușurează testarea și compoziția pașilor.</li>
<li>**Complexitate.** Tokenizarea este `O(T)`; construirea acrostihului este `O(n)`. Consum de memorie `O(n)` pentru tokeni și rezultat. Pentru texte foarte mari, luați în calcul **iteratoare/streaming** (vezi variațiunea L).</li>
<h2>Lansări rapide (toate scripturile)</h2>
<pre><code>
for f in 5acrostih*.js; do echo &quot;== $f ==&quot;; node &quot;$f&quot;; done
</code></pre>
</ul>
<p></p>
<h2>Variațiuni didactice propuse (I–N)</h2>
<ul>
<li>`5acrostihI_unicode.js` — **tokenizare Unicode** cu `\p{L}+` (diacritice) și opțiune pentru `toUpperCase`.</li>
<li>`5acrostihJ_stopwords_locale.js` — **stopwords** parametrizabil, cu **normalizare NFD** (înlăturarea diacriticelor) și `toLowerCase`.</li>
<li>`5acrostihK_module.mjs` — modul ES (`export`) cu funcții reutilizabile și exemplu minimal de test cu `node:test`.</li>
<li>`5acrostihL_stream.js` — **streaming** din fișier/STDIN (iterator asincron), memorie `O(1)` extra.</li>
<li>`5acrostihM_telestich.js` — „**telestih**” (ultima literă a fiecărui cuvânt) și opțional „mesostih” (literă interioară).</li>
<li>`5acrostihN_detect.js` — verifică dacă textul/șirul de cuvinte **encodează** un acrostih dat (`--target=...`).</li>
</ul>
<p></p>
<hr/>
<h2>Referințe (APA, ediția a 7‑a)</h2>
<ul>
<li>Thompson, K. (1968). Regular expression search algorithm. *Communications of the ACM, 11*(6), 419–422. https://doi.org/10.1145/363347.363387</li>
<li>Knuth, D. E., Morris, J. H., &amp; Pratt, V. R. (1977). Fast pattern matching in strings. *SIAM Journal on Computing, 6*(2), 323–350. https://doi.org/10.1137/0206024</li>
<li>Aho, A. V., &amp; Corasick, M. J. (1975). Efficient string matching: An aid to bibliographic search. *Communications of the ACM, 18*(6), 333–340. https://doi.org/10.1145/360825.360855</li>
<li>Yergeau, F. (2003). UTF-8, a transformation format of ISO 10646 (RFC 3629). RFC Editor. https://doi.org/10.17487/RFC3629</li>
<li>Bray, T. (2017). The JavaScript Object Notation (JSON) Data Interchange Format (RFC 8259). RFC Editor. https://doi.org/10.17487/RFC8259</li>
<li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2022). *Introduction to algorithms* (4th ed.). MIT Press. https://doi.org/10.7551/mitpress/11838.001.0001</li>
</ul>
</body></html>