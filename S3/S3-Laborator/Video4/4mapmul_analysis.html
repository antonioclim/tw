<!doctype html><html><head><meta charset="utf-8"><title>4mapmul Analysis</title>
<style>body{font-family:Georgia,serif;max-width:900px;margin:40px auto;line-height:1.6}
pre{background:#f6f8fa;padding:12px;overflow:auto;border:1px solid #e1e4e8}
code{font-family:ui-monospace,Consolas,monospace}
h1,h2,h3{font-family:Cambria,Georgia,serif}
hr{border:none;border-top:1px solid #ccc;margin:2em 0}
ul{margin-left:1.2em}
a{color:inherit;text-decoration:underline}
</style></head><body>
<h1>4mapmul (A–D): analiză tehnică și comentarii didactice</h1>
<p></p>
<p>_Generat: 2025-10-13T13:44:07_</p>
<p></p>
<h2>Context</h2>
<p>Aceste scripturi ilustrează folosirea lui `Array.prototype.map` pentru a **înmulți** fiecare element al unui tablou numeric cu un factor (implicit `2`), în mai multe stiluri (expresie concisă, funcție helper, variabilă intermediară, **CLI**). Setul este util pentru introducerea stilului funcțional, a imutabilității colecțiilor și a ergonomiei CLI în Node.js.</p>
<p></p>
<h3>4mapmulA.js</h3>
<p>**Varianta A — expresie concisă în `console.log`.** Demonstrează *arrow function* fără acolade (return **implicit**).</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map, &quot;use strict&quot;.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `2`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** timp `O(n)` (o trecere peste cei `n` itemi), spațiu `O(n)` pentru rezultatul mapării.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(f)` **nu modifică** tabloul sursă; construiește un **tablou nou** mapând fiecare element `x` la `f(x)`; ordinea elementelor se păstrează.</li>
<li>Funcția de mapare `x =&gt; x * mul` este o **funcție pură** (nu are efecte secundare) — condiție recomandată pentru predictibilitate.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 4mapmulA.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Varianta A — direct în `console.log`: sample.map(x =&gt; x * 2)
 * Exemplu simplu de funcție săgeată concisă.
 * Explicatie:
 *   - fără acolade, deci o singură expresie
 *   - valoarea expresiei este returnată implicit
 */

// &quot;use strict&quot;;
const sample = [1, 2, 3, 4, 5];
console.log(sample.map((x) =&gt; x * 2));

// =&gt; [ 2, 4, 6, 8, 10 ]
</code></pre>
<p></p>
<h3>4mapmulB.js</h3>
<p>**Varianta B — funcție ajutătoare `double`.** Separă funcția de transformare de apel, crescând lizibilitatea și favorizând reutilizarea/testarea.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `3`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** timp `O(n)` (o trecere peste cei `n` itemi), spațiu `O(n)` pentru rezultatul mapării.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(f)` **nu modifică** tabloul sursă; construiește un **tablou nou** mapând fiecare element `x` la `f(x)`; ordinea elementelor se păstrează.</li>
<li>Funcția de mapare `x =&gt; x * mul` este o **funcție pură** (nu are efecte secundare) — condiție recomandată pentru predictibilitate.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 4mapmulB.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Varianta B — funcție ajutătoare `double` și apoi `sample.map(double)`
 * (aceeași logică; dar ceva mai lizibil în demouri didactice)
 * Explicație:
 *   - funcția `double` primește un număr și returnează dublul său
 *   - `sample.map(double)` aplică funcția `double` fiecărui element din array
 *   - rezultatul este un nou array cu valorile dublate
 */


const sample = [1, 2, 3, 4, 5];
const double = (x) =&gt; { return x * 2; };
console.log(sample.map(double));


// =&gt; [ 2, 4, 6, 8, 10 ]
</code></pre>
<p></p>
<h3>4mapmulC.js</h3>
<p>**Varianta C — variabilă intermediară.** Reține rezultatul în `doubled` înainte de afișare — util în **debugging** și pentru pași suplimentari.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), Array.prototype.map.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `3`, complexitate ciclomatică (aprox.) ≈ `1`.</p>
<p>**Complexitate asimptotică:** timp `O(n)` (o trecere peste cei `n` itemi), spațiu `O(n)` pentru rezultatul mapării.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(f)` **nu modifică** tabloul sursă; construiește un **tablou nou** mapând fiecare element `x` la `f(x)`; ordinea elementelor se păstrează.</li>
<li>Funcția de mapare `x =&gt; x * mul` este o **funcție pură** (nu are efecte secundare) — condiție recomandată pentru predictibilitate.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 4mapmulC.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Varianta C — map într-o variabilă intermediară, apoi afișare
 * (același efect, dar mai ușor de inspectat - debugging)
 * Explicație:
 *   - folosim `sample.map(...)` pentru a crea un nou array cu valorile dublate
 *   - rezultatul este stocat în variabila `doubled`
 *   - apoi afișăm conținutul lui `doubled`
 */


const sample = [1, 2, 3, 4, 5];
const doubled = sample.map((x) =&gt; x * 2);
console.log(doubled);

// =&gt; [ 2, 4, 6, 8, 10 ]
</code></pre>
<p></p>
<h3>4mapmulD.js</h3>
<p>**Varianta D — CLI parametric.** `parseArgs` → `--arr=...` și `--mul=...`; parsează lista (CSV), convertește la `Number`, filtrează non‑finite și aplică maparea.</p>
<p>**Stil &amp; API‑uri:** funcții săgeată (ES6), funcții clasice (ES5), Array.prototype.map, iterație `for`, CLI Node.js.</p>
<p>**Măsuri:** linii de cod (fără comentarii/blank) ≈ `15`, complexitate ciclomatică (aprox.) ≈ `8`.</p>
<p>**Complexitate asimptotică:** timp `O(n)` (o trecere peste cei `n` itemi), spațiu `O(n)` pentru rezultatul mapării.</p>
<p>**Explicații pe cod (esențial):**</p>
<ul>
<li>`map(f)` **nu modifică** tabloul sursă; construiește un **tablou nou** mapând fiecare element `x` la `f(x)`; ordinea elementelor se păstrează.</li>
<li>Funcția de mapare `x =&gt; x * mul` este o **funcție pură** (nu are efecte secundare) — condiție recomandată pentru predictibilitate.</li>
</ul>
<p></p>
<p>**Rulare în Node.js:**</p>
<pre><code>
node 4mapmulD.js
</code></pre>
<p></p>
<p>**Cod sursă (extras):**</p>
<pre><code>
/**
 * Varianta D — CLI parametric - permite specificarea array-ului și a multiplicatorului din linia de comandă:
 *   node script.js --arr=1,2,3,4,5 --mul=2
 * Dacă nu se dau argumente, folosește [1,2,3,4,5] și multiplicatorul 2.
 * Explicație:
 *   - parseArgs: funcție care parsează argumentele din linia de comandă în obiect
 *   - arr: șir cu elementele separate prin virgulă, de exemplu &quot;1,2,3,4,5&quot; 
 * Utilitate practică: permite reutilizarea scriptului cu diferite seturi de date.
 *   - mul: multiplicatorul, de exemplu 2
 *   - se folosește map pentru a crea un nou array cu valorile înmulțite
 *   - rezultatul este afișat în consolă
 */
function parseArgs(argv) {
  const args = {};
  for (let i = 2; i &lt; argv.length; i++) {
    const [k, v] = argv[i].split(&quot;=&quot;);
    if (k &amp;&amp; k.startsWith(&quot;--&quot;)) args[k.slice(2)] = v ?? &quot;&quot;;
  }
  return args;
}

const args = parseArgs(process.argv);
const arr = args.arr
  ? String(args.arr).split(&quot;,&quot;).map(s =&gt; Number(s.trim())).filter(Number.isFinite)
  : [1, 2, 3, 4, 5];

const mul = Number.isFinite(Number(args.mul)) ? Number(args.mul) : 2;

const out = arr.map(x =&gt; x * mul);
console.log(out);
</code></pre>
<p></p>
<hr/>
<h2>Discuție transversală</h2>
<ul>
<li>**Stil funcțional vs imperativ.** `map` declară *ce* transformare aplicăm; bucla `for` detaliază *cum*. Pentru colecții mari, diferențele practice depind de runtime și JIT, dar ambele sunt `O(n)` în timp.</li>
<li>**Imutabilitate.** Rezultatul `map` este un **nou tablou**, iar sursa rămâne neschimbată — proprietate esențială pentru compunerea pașilor de prelucrare și testare.</li>
<li>**Tipuri numerice.** JavaScript folosește IEEE‑754 *double*; pentru integrale mari sau precizie fixă există `BigInt` — vezi variațiunea **G**.</li>
<li>**Date mari.** Pentru fluxuri lungi, streaming/iterator poate reduce presiunea de memorie — vezi variațiunea **J** (iterator).</li>
<h2>Lansări rapide (toate scripturile)</h2>
<pre><code>
for f in 4mapmul*.js; do echo &quot;== $f ==&quot;; node &quot;$f&quot;; done
</code></pre>
</ul>
<p></p>
<h2>Variațiuni didactice propuse (E–J)</h2>
<ul>
<li>`4mapmulE_forLoop.js` — buclă **imperativă** (o singură trecere, `O(1)` extra).</li>
<li>`4mapmulF_reduceMap.js` — **map cu `reduce`** (didactic; evită apelul `map`).</li>
<li>`4mapmulG_bigint.js` — suport pentru **BigInt** (nu amestecați cu `Number`).</li>
<li>`4mapmulH_typedArray.js` — **TypedArray** (`Float64Array`), util pentru procesări numerice dense.</li>
<li>`4mapmulI_benchmark.js` — micro‑benchmark: `map` vs `for` vs `reduce`.</li>
<li>`4mapmulJ_iterator.js` — **generator**/iterator care emite pe rând valorile înmulțite (memorie `O(1)`).</li>
</ul>
<p></p>
<hr/>
<h2>Referințe (APA, ediția a 7‑a)</h2>
<ul>
<li>Backus, J. (1978). Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. *Communications of the ACM, 21*(8), 613–641. https://doi.org/10.1145/359576.359579</li>
<li>Hutton, G. (1999). A tutorial on the universality and expressiveness of fold. *Journal of Functional Programming, 9*(4), 355–372. https://doi.org/10.1017/S0956796899003500</li>
<li>IEEE. (2019). IEEE Standard for Floating‑Point Arithmetic (IEEE Std 754‑2019). https://doi.org/10.1109/IEEESTD.2019.8766229</li>
<li>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2022). *Introduction to algorithms* (4th ed.). MIT Press. https://doi.org/10.7551/mitpress/11838.001.0001</li>
</ul>
</body></html>