<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestionarea erorilor Ã®ntr-o aplicaÈ›ie RESTful Express.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            color: #333;
            background: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 50px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        h1 {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 40px;
            border-bottom: 4px solid #fc466b;
            padding-bottom: 20px;
            text-align: center;
        }

        h2 {
            font-size: 1.8em;
            color: #34495e;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-left: 15px;
            border-left: 5px solid #fc466b;
        }

        h3 {
            font-size: 1.4em;
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        h4 {
            font-size: 1.2em;
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 12px;
            font-weight: 600;
        }

        p {
            margin-bottom: 20px;
            text-align: justify;
            font-size: 1.05em;
        }

        .first-paragraph::first-letter {
            font-size: 3em;
            font-weight: bold;
            float: left;
            line-height: 0.8;
            margin: 0.1em 0.1em 0 0;
            color: #fc466b;
        }

        strong {
            color: #d63031;
            font-weight: 600;
        }

        em {
            color: #16a085;
            font-style: italic;
        }

        code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
            font-size: 0.95em;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 25px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        pre code {
            background: transparent;
            color: #ecf0f1;
            padding: 0;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .code-block {
            margin: 25px 0;
            position: relative;
        }

        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: -10px;
            right: 20px;
            background: #fc466b;
            color: white;
            padding: 3px 10px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
        }

        .note {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px 20px;
            margin: 25px 0;
            border-radius: 5px;
        }

        .important {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px 20px;
            margin: 25px 0;
            border-radius: 5px;
        }

        .tip {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 15px 20px;
            margin: 25px 0;
            border-radius: 5px;
        }

        .success {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px 20px;
            margin: 25px 0;
            border-radius: 5px;
        }

        ul, ol {
            margin: 20px 0 20px 40px;
        }

        li {
            margin: 10px 0;
        }

        .references {
            margin-top: 60px;
            padding-top: 30px;
            border-top: 2px solid #e0e0e0;
        }

        .references h2, .references h3 {
            color: #7f8c8d;
        }

        .references p {
            font-size: 0.95em;
            color: #7f8c8d;
            margin-bottom: 10px;
        }

        .references a {
            color: #fc466b;
            text-decoration: none;
            word-break: break-all;
        }

        .references a:hover {
            text-decoration: underline;
            color: #d63031;
        }

        sup {
            color: #fc466b;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
            }

            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }
        }

        @media print {
            body {
                background: white;
            }

            .container {
                box-shadow: none;
                padding: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>S8seg7: Gestionarea erorilor Ã®ntr-o aplicaÈ›ie RESTful Express.js</h1>
<h2><strong>Introducere</strong></h2>
<p class="first-paragraph">Ãn dezvoltarea aplicaÈ›iilor, apar inevitabil erori atÃ¢t la nivelul aplicaÈ›iei, cÃ¢t È™i la nivel de reÈ›ea. <strong>Erorile de aplicaÈ›ie</strong> sunt probleme interne ale serverului â€“ de exemplu, bug-uri Ã®n cod sau excepÈ›ii neaÈ™teptate care duc la <em>500 Internal Server Error</em>. <strong>Erorile de reÈ›ea</strong> (sau de client) apar atunci cÃ¢nd cererea trimisÄƒ de utilizator este problematicÄƒ â€“ de pildÄƒ, solicitarea unei resurse inexistente, care rezultÄƒ Ã®n un <em>404 Not Found</em>. Cu alte cuvinte, un rÄƒspuns HTTP <strong>404 Not Found</strong> indicÄƒ faptul cÄƒ serverul nu poate gÄƒsi resursa cerutÄƒ (URL-ul nu este recunoscut), pe cÃ¢nd un <strong>500 Internal Server Error</strong> indicÄƒ o situaÈ›ie internÄƒ pe care serverul nu È™tie cum sÄƒ o gestioneze (un fel de eroare genericÄƒ cÃ¢nd serverul nu are un cod mai potrivit de returnat). Ãn mod implicit, Express trateazÄƒ aceste cazuri automat: dacÄƒ un client cere o rutÄƒ inexistentÄƒ, Express va trimite un status <code>404</code>, iar dacÄƒ serverul Ã®ntÃ¢mpinÄƒ o eroare neaÈ™teptatÄƒ Ã®n timpul execuÈ›iei unei rute, va trimite un <code>500</code>.</p>
<p>Este important sÄƒ Ã®nÈ›elegem sursa acestor erori. Ãn general, putem distinge douÄƒ categorii mari de probleme Ã®n backend: (1) <strong>erori programatice</strong> â€“ cauzate de bug-uri sau excepÈ›ii Ã®n codul serverului (de exemplu folosirea unei variabile nedefinite, aruncarea unei erori cu throw etc.), È™i (2) <strong>erori cauzate de utilizator</strong> â€“ rezultate din acÈ›iuni sau input incorect din partea clientului (de exemplu, cereri cÄƒtre rute greÈ™ite sau date de intrare invalide). Un articol ButterCMS (Kosisochukwu, 2024) subliniazÄƒ cÄƒ erorile programatice apar din probleme ale codului, pe cÃ¢nd erorile operaÈ›ionale (cauzate de condiÈ›ii externe sau input) trebuie gestionate graÈ›ios la runtime. Ãn contextul nostru, o eroare programaticÄƒ la Hogwarts ar fi ca atunci cÃ¢nd o vrajÄƒ se Ã®ntoarce Ã®mpotriva profesorului din cauza unei incantaÈ›ii greÈ™ite (bug Ã®n cod), iar o eroare cauzatÄƒ de utilizator ar fi ca atunci cÃ¢nd un elev Ã®ncearcÄƒ sÄƒ acceseze o vrajÄƒ inexistentÄƒ Ã®n bibliotecÄƒ (ruta greÈ™itÄƒ).</p>
<p><strong>Gestionarea centralizatÄƒ a erorilor</strong> Ã®n Express este esenÈ›ialÄƒ pentru a menÈ›ine aplicaÈ›ia robustÄƒ È™i uÈ™or de Ã®ntreÈ›inut. Ãn loc sÄƒ tratÄƒm erorile punctual Ã®n fiecare rutÄƒ, Express ne permite sÄƒ definim un <em>middleware</em> global de tratare a erorilor care va intercepta toate excepÈ›iile neprevÄƒzute. Acest lucru asigurÄƒ consistenÈ›a rÄƒspunsurilor È™i evitÄƒ oprirea bruscÄƒ a execuÈ›iei aplicaÈ›iei la apariÈ›ia unei erori. DupÄƒ cum noteazÄƒ Kosisochukwu (2024), un management corespunzÄƒtor al erorilor face diferenÈ›a Ã®ntre a rezolva un bug Ã®n cÃ¢teva minute sau Ã®n cÃ¢teva ore, permiÈ›Ã¢nd tratarea graÈ›ioasÄƒ a excepÈ›iilor fÄƒrÄƒ a opri nejustificat aplicaÈ›ia. De asemenea, Express vine cu un handler implicit de erori care, dacÄƒ nu definim unul personalizat, trimite clientului detalii despre eroare (inclusiv <em>stack trace</em>-ul) Ã®n modul de dezvoltare, iar Ã®n modul de producÈ›ie omite <em>stack trace</em>-ul pentru a proteja aplicaÈ›ia. Cu un middleware propriu, putem controla acest comportament È™i personaliza mesajele de eroare.</p>
<p>Un alt aspect teoretic important este diferenÈ›a de abordare Ã®ntre erorile <code>500</code> È™i <code>404</code> Ã®n Express. Conform documentaÈ›iei oficiale Express.js, rÄƒspunsurile <code>404</code> nu sunt rezultatul unei erori interne, ci indicÄƒ pur È™i simplu cÄƒ nicio rutÄƒ definitÄƒ nu a putut rÄƒspunde cererii â€“ cu alte cuvinte, Express a epuizat toate funcÈ›iile middleware È™i rutele posibile fÄƒrÄƒ sÄƒ gÄƒseascÄƒ un rÄƒspuns potrivit. Din acest motiv, erorile 404 <em>nu sunt preluate de middleware-ul de eroare</em> (care intercepteazÄƒ doar erorile apÄƒrute efectiv Ã®n timpul execuÈ›iei unei rute existente). Pentru a gestiona <strong>404 Not Found</strong>, trebuie sÄƒ adÄƒugÄƒm manual un <em>middleware</em> special la finalul listei de rute, care sÄƒ prindÄƒ orice solicitare neacoperitÄƒ È™i sÄƒ Ã®ntoarcÄƒ un rÄƒspuns 404 personalizat. Ãn schimb, erorile interne (500) apÄƒrute Ã®ntr-o rutÄƒ (de exemplu prin throw sau next(err)) vor declanÈ™a middleware-ul global de eroare dacÄƒ acesta este definit, sau Ã®n absenÈ›a lui vor fi gestionate de handler-ul implicit Express (care seteazÄƒ automat status 500 È™i trimite un mesaj generic sau stack trace-ul Ã®n funcÈ›ie de mediu).</p>
<p>Pe scurt, <strong>gestionarea erorilor</strong> Ã®ntr-o API Express RESTful implicÄƒ identificarea clarÄƒ a tipului de eroare (eroare de client vs. eroare de server) È™i tratarea centralizatÄƒ a ambelor cazuri: <em>erorile interne</em> (500) printr-un middleware de eroare global, respectiv <em>rutele inexistente</em> (404) printr-un middleware â€œcatch-allâ€ plasat la final. Ãn continuare vom vedea cum implementÄƒm practic aceste mecanisme, folosind Ã®n continuare analogia Hogwarts pentru exemple.</p>
<h2><strong>ExplicaÈ›ie</strong></h2>
<p>SÄƒ trecem la abordarea practicÄƒ a problemei: <strong>cum definim È™i configurÄƒm middleware-urile de tratare </strong><strong>a</strong><strong> erorilor Ã®n Express</strong>. Vom avea nevoie de douÄƒ middleware-uri principale la nivel de aplicaÈ›ie Express:</p>
<p><strong>Middleware global de eroare (500)</strong> â€“ o funcÈ›ie specialÄƒ cu <strong>patru</strong> argumente, semnÄƒtura fiind function(err, req, res, next). PrezenÈ›a celor patru parametri Ã®i semnaleazÄƒ lui Express cÄƒ aceasta este o funcÈ›ie de tratare a erorilor. Aceasta va intercepta orice eroare apÄƒrutÄƒ Ã®n rutÄƒ (transmisÄƒ fie prin throw, fie prin apelarea next(err) Ã®n cod) È™i va genera un rÄƒspuns adecvat cÄƒtre client (de obicei un status 500 È™i un mesaj JSON). Conform FAQ-ului Express, definirea unui astfel de handler se face la fel ca la orice alt middleware, doar cÄƒ include parametrul suplimentar <code>err</code> la Ã®nceput. <strong>Important:</strong> Acest middleware trebuie ataÈ™at <strong>dupÄƒ toate celelalte rute È™i middleware-uri</strong> din aplicaÈ›ie, pentru a fi invocat doar cÃ¢nd ceva a mers rÄƒu È™i nu a fost deja rÄƒspuns.</p>
<p><strong>Middleware â€œ404 Not Foundâ€ (catch-all)</strong> â€“ o funcÈ›ie middleware obiÈ™nuitÄƒ (cu trei argumente req, res, next) plasatÄƒ <strong>la finalul lanÈ›ului</strong> de route-handlers, care va trata orice cerere care nu a fost preluatÄƒ de vreo rutÄƒ definitÄƒ anterior. Practic, dacÄƒ execuÈ›ia ajunge la acest middleware, Ã®nseamnÄƒ cÄƒ nicio rutÄƒ nu s-a potrivit, deci vom returna un rÄƒspuns cu eroarea 404. DocumentaÈ›ia Express recomandÄƒ adÄƒugarea unei astfel de funcÈ›ii la final, care seteazÄƒ codul de status la 404 È™i trimite un mesaj potrivit, de exemplu: <code>res.status(404).send(&quot;Sorry can&#x27;t find that!&quot;)</code>. Ãntr-o API RESTful vom trimite un rÄƒspuns JSON Ã®n loc de text simplu, dar principiul rÄƒmÃ¢ne acelaÈ™i. Acest middleware de 404 <strong>nu foloseÈ™te</strong> parametrul <code>err</code> (nu e un handler de eroare propriu-zis, ci un fallback pentru rutele lipsÄƒ).</p>
<p>Ãn continuare vom detalia cum se scriu efectiv aceste middleware-uri Ã®n cod È™i ce format au rÄƒspunsurile JSON trimise clientului.</p>
<h3>Middleware-ul global de eroare (<strong>handler 500</strong>)</h3>
<p>Un <strong>middleware de eroare</strong> Express are forma generalÄƒ:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>app.use((err, req, res, next) =&gt; {
    // cod de tratare a erorii
});</code></pre>
</div>
<p>ObservaÈ›i prezenÈ›a celor patru parametri â€“ acesta este modul Ã®n care Express identificÄƒ funcÈ›ia ca fiind destinatÄƒ <strong>doar</strong> erorilor. AceastÄƒ funcÈ›ie va fi apelatÄƒ automat de Express ori de cÃ¢te ori un middleware sau o rutÄƒ a apelat next(err) sau a aruncat o excepÈ›ie. Ãn interiorul handler-ului, avem acces la obiectul <code>err</code> care descrie eroarea. Putem folosi acest obiect pentru a loga problema (ex: <code>console.error(err.stack)</code> pentru a afiÈ™a stack trace-ul Ã®n consolÄƒ) È™i pentru a trimite un rÄƒspuns cÄƒtre client.</p>
<p>Ãn cazul unei aplicaÈ›ii <strong>RESTful</strong> precum API-ul Hogwarts, este recomandat sÄƒ trimitem erorile Ã®n format <strong>JSON</strong>, astfel Ã®ncÃ¢t clientul (de exemplu front-end-ul sau un alt serviciu) sÄƒ poatÄƒ interpreta uÈ™or rÄƒspunsul. Un exemplu simplu de implementare a middleware-ului de eroare ar putea fi:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>// Middleware global de tratare a erorilor
app.use((err, req, res, next) =&gt; {
    console.error(&quot;[Eroare]&quot;, err.stack);  // Log pentru debug (Ã®n consolÄƒ)
    // SetÄƒm statusul HTTP la 500 (Internal Server Error) 
    // È™i trimitem un JSON cu un mesaj generic de eroare.
    res.status(500).json({ 
        error: &quot;Something went wrong on the server.&quot;,  // mesaj generic pentru client
        status: 500 
    });
});</code></pre>
</div>
<p>Ãn codul de mai sus, <strong>ultimul middleware adÄƒugat</strong> pe app intercepteazÄƒ erori È™i trimite un rÄƒspuns cu status 500 È™i corp JSON. Mesajul &quot;Something went wrong on the server.&quot; este unul generic, potrivit pentru mediul de producÈ›ie (unde nu vrem sÄƒ divulgÄƒm detalii interne). Ãn mediu de dezvoltare am putea include mai multe informaÈ›ii (de exemplu <code>err.message</code> sau alte detalii) pentru a facilita debugging-ul. Best practice este sÄƒ <strong>nu trimitem </strong><strong>stack trace</strong><strong>-ul sau informaÈ›ii sensibile cÄƒtre client</strong>, deoarece acestea pot constitui un risc de securitate È™i oricum nu ajutÄƒ utilizatorul final. Ãn schimb, se poate loga intern complet eroarea (Ã®n consolÄƒ sau Ã®ntr-un fiÈ™ier de log), dar rÄƒspunsul cÄƒtre client sÄƒ conÈ›inÄƒ doar un mesaj prietenos È™i eventual un cod de eroare.</p>
<p>De asemenea, observÄƒm cÄƒ am folosit <code>res.status(500)</code> Ã®nainte de .json(...). Setarea codului HTTP corect este esenÈ›ialÄƒ: <code>500</code> indicÄƒ faptul cÄƒ a fost o eroare de server. Alternativ, dacÄƒ am anticipa È™i erori de alt tip, am putea folosi proprietÄƒÈ›i custom ale obiectului <code>err</code> â€“ de pildÄƒ unele convenÈ›ii adaugÄƒ err.statusCode sau <code>err.status</code> la erorile aruncate intenÈ›ionat. Express Ã®nsÄƒ, Ã®n handler-ul sÄƒu implicit, verificÄƒ dacÄƒ eroarea are o proprietate status sau statusCode È™i foloseÈ™te acea valoare; dacÄƒ nu, atribuie automat 500. Ãn implementarea noastrÄƒ personalizatÄƒ, putem face ceva similar: de exemplu <code>res.status(err.status || 500).json({ ... })</code> pentru a trata È™i erori cu alt cod. Ãn contextul de faÈ›Äƒ ne concentrÄƒm pe 500, deci nu intrÄƒm Ã®n detalii despre erori 400 (Bad Request) sau altele â€“ doar reÈ›inem cÄƒ <strong>erorile intenÈ›ionat provocate</strong> (ex: validÄƒri eÈ™uate) ar trebui marcate cu un cod corespunzÄƒtor (precum 400) È™i pot fi de asemenea prinse de acelaÈ™i middleware global, dacÄƒ setÄƒm statusul Ã®n obiectul de eroare.</p>
<p><strong>AmplasaÈ›i acest middleware la finalul configuraÈ›iei Express.</strong> DupÄƒ definirea tuturor rutelor È™i celorlalte middleware (de parsing, autentificare etc.), se apeleazÄƒ <code>app.use(handlerDeEroare)</code>. Ãn acest mod, suntem siguri cÄƒ orice eroare produsÄƒ oriunde Ã®n flux va ajunge aici dacÄƒ nu a fost deja tratatÄƒ. Practic, Express menÈ›ine un â€œstackâ€ de middleware-uri, iar handler-ul de erori va sta ultimul la rÃ¢nd. Ãn exemplul nostru Hogwarts, ne putem imagina cÄƒ acest handler global este ca un <em>Profesor de ApÄƒrare contra Magiei Negre</em> care stÄƒ mereu de veghe la final pentru a prinde orice blestem scÄƒpat de sub control Ã®n timpul execuÈ›iei .</p>
<h3>Middleware-ul <code>404</code> â€œNot Foundâ€ (<strong>rute inexistente</strong>)</h3>
<p>UrmÄƒtorul aspect este gestionarea cererilor cÄƒtre <strong>rute inexistente</strong>. AÈ™a cum am discutat, Express nu considerÄƒ lipsa unei rute ca fiind o â€œeroareâ€ Ã®n sens intern, aÈ™a cÄƒ <strong>nu va trimite automat cÄƒtre middleware-ul de eroare</strong> cazul unui 404. Ãn schimb, dacÄƒ nicio rutÄƒ nu rÄƒspunde, serverul Express pur È™i simplu va Ã®nchide cererea cu un status 404 implicit. Ca sÄƒ personalizÄƒm acest comportament È™i sÄƒ oferim clientului un mesaj util (È™i eventual tot JSON), adÄƒugÄƒm un <strong>middleware â€œcatch-allâ€</strong> la sfÃ¢rÈ™itul definiÈ›iilor de rute.</p>
<p>Acest middleware 404 va arÄƒta astfel:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>// Middleware pentru rutele neimplementate (404 Not Found)
app.use((req, res, next) =&gt; {
    res.status(404).json({
        error: &quot;Not found&quot;,
        status: 404
    });
});</code></pre>
</div>
<p>Ce face acest cod? Fiind plasat dupÄƒ toate celelalte rute posibile (<code>app.use</code>/<code>app.get</code>/<code>app.post</code> etc.), el va fi executat doar dacÄƒ nicio rutÄƒ definitÄƒ nu a trimis deja un rÄƒspuns. Parametrii <code>req</code> È™i <code>res</code> ne permit sÄƒ accesÄƒm detalii despre cerere â€“ de exemplu am putea include req.originalUrl È™i metoda HTTP Ã®n mesaj pentru a preciza ce resursÄƒ nu a fost gÄƒsitÄƒ. Ãn exemplu am trimis simplu { &quot;error&quot;: &quot;Not found&quot;, &quot;status&quot;: 404 }, dar putem Ã®mbogÄƒÈ›i mesajul. Important este sÄƒ setÄƒm <strong>codul de status 404</strong> È™i sÄƒ trimitem un JSON care sÄƒ informeze clientul cÄƒ resursa cerutÄƒ nu existÄƒ.</p>
<p>Express FAQ sugereazÄƒ exact acest tip de handler, exemplificÃ¢nd cu un mesaj simplu de scuzÄƒ. Ãn API-uri, un mesaj mai tehnic este acceptabil. De exemplu, am putea trimite { &quot;error&quot;: &quot;Ruta nu existÄƒ&quot; } sau { &quot;error&quot;: &quot;Resource /spells/abc not found&quot; }. Ãn context Hogwarts, dacÄƒ un student cere o vrajÄƒ inexistentÄƒ, i-am putea rÄƒspunde cu un mesaj pe mÄƒsurÄƒ, dar Ã®n termeni tehnici pÄƒstrÄƒm claritatea: resursa cerutÄƒ nu a fost gÄƒsitÄƒ pe server.</p>
<p>Trebuie menÈ›ionat cÄƒ putem realiza gestionarea 404 È™i Ã®ntr-un mod uÈ™or diferit: Ã®n loc sÄƒ trimitem direct rÄƒspunsul Ã®n acest middleware, am putea apela <code>next()</code> cu o eroare 404 cÄƒtre handler-ul global. De exemplu:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>app.use((req, res, next) =&gt; {
    const err = new Error(&quot;Not Found&quot;);
    err.status = 404;
    next(err);
});</code></pre>
</div>
<p>Acest tipar ar transmite o eroare cu status 404 mai departe cÄƒtre middleware-ul de eroare definit anterior, care ar trebui adaptat sÄƒ diferenÈ›ieze Ã®ntre 404 È™i 500. Unele generaÈ›ii de proiecte Express folosesc modul acesta (de pildÄƒ, pachete ca http-errors pot crea obiecte de eroare specifice codurilor). <strong>Pentru simplitate Ã®nsÄƒ, Ã®n exemplul nostru vom folosi prima variantÄƒ</strong>, trimiÈ›Ã¢nd direct rÄƒspunsul 404 din middleware-ul dedicat. Acest lucru este suficient pentru majoritatea cazurilor È™i clar din punct de vedere al fluxului: ai ajuns la final, returnezi 404 È™i Ã®nchei procesarea cererii, fÄƒrÄƒ a mai invoca handler-ul general de erori.</p>
<p>AÈ™adar, reÈ›ineÈ›i: <strong>middleware-ul 404</strong> vine imediat <em>Ã®nainte</em> de middleware-ul de eroare Ã®n ordinea configuraÈ›iilor È™i <em>dupÄƒ</em> toate rutele. El prinde toate rutele neacoperite È™i rÄƒspunde separat, deoarece nu este vorba de o eroare a aplicaÈ›iei, ci de o cerere invalidÄƒ (din perspectiva serverului, clientul a greÈ™it adresa).</p>
<h3><strong>Structura </strong>rÄƒspunsurilor <strong>JSON de eroare</strong></h3>
<p>AtÃ¢t pentru erori interne, cÃ¢t È™i pentru rutele inexistente, <strong>rÄƒspunsurile</strong> pe care le oferim vor fi Ã®n format JSON, cuprinzÃ¢nd tipic un camp care indicÄƒ eroarea. Ãn exemplele de mai sus am inclus douÄƒ cÃ¢mpuri: <code>error</code> (cu o descriere sau mesaj) È™i status (codul numeric HTTP, redundat informativ). Structura exactÄƒ poate varia Ã®n funcÈ›ie de preferinÈ›e sau convenÈ›ii. Un format minimalist este sÄƒ trimitem doar un obiect cu un mesaj, de exemplu:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>{ &quot;error&quot;: &quot;Something went wrong&quot; }</code></pre>
</div>
<p>cum sugera enunÈ›ul. TotuÈ™i, este adesea util sÄƒ includem È™i codul de status sau un cod de eroare intern. Ãn aplicaÈ›ii mai mari, am putea avea un format precum:</p>
<p>{
   &quot;success&quot;: false,
   &quot;error&quot;: {
       &quot;code&quot;: 404,
       &quot;message&quot;: &quot;Not found&quot;
   }
}</p>
<p>Pentru simplitate, Ã®n lecÈ›ia de faÈ›Äƒ rÄƒmÃ¢nem la { error: &quot;...&quot;, status: ... }. Acest format permite clientului sÄƒ È™tie clar ce s-a Ã®ntÃ¢mplat (prin mesaj) È™i sÄƒ aibÄƒ È™i codul numeric (deÈ™i acesta vine È™i ca status HTTP). Important este sÄƒ fim <strong>consecvenÈ›i</strong>: gestionarea centralizatÄƒ a erorilor tocmai acest avantaj Ã®l are â€“ toate erorile vor fi livrate Ã®n acelaÈ™i mod, indiferent de unde apar. Astfel, cei care consumÄƒ API-ul (fie dezvoltatori front-end, fie alte servicii) vor È™ti la ce sÄƒ se aÈ™tepte. De exemplu, pot implementa logicÄƒ de front-end care verificÄƒ dacÄƒ rÄƒspunsul are <code>error</code> È™i status È™i afiÈ™eazÄƒ un anumit mesaj pentru 404 sau 500, etc.</p>
<p>Ãn concluzie pentru aceastÄƒ secÈ›iune aplicatÄƒ: am configurat douÄƒ middleware-uri esenÈ›iale â€“ unul pentru erori interne (500) È™i unul catch-all pentru rutele lipsÄƒ (404). Ambele trimit rÄƒspunsuri JSON structurate. Ãn secÈ›iunea urmÄƒtoare vom vedea un exemplu practic complet, cu cod È™i scenarii de test, folosind analogia Hogwarts pentru a simula situaÈ›iile de eroare.</p>
<h2><strong>Exemplu</strong></h2>
<p>SÄƒ punem cap la cap conceptele de mai sus Ã®ntr-un exemplu concret. ImaginaÈ›i-vÄƒ cÄƒ dezvoltÄƒm o micÄƒ aplicaÈ›ie Express pentru biblioteca de vrÄƒji de la Hogwarts. Avem cÃ¢teva rute, printre care vom defini special una care <strong>simuleazÄƒ o eroare internÄƒ</strong> (poate o vrajÄƒ care dÄƒ greÈ™) È™i vom vedea cum acÈ›ioneazÄƒ middleware-urile noastre de eroare. De asemenea, vom verifica comportamentul pentru o rutÄƒ inexistentÄƒ.</p>
<p>Mai jos este un exemplu de cod JavaScript (simplificat) pentru serverul Express al aplicaÈ›iei Hogwarts. Comentariile adnotate explicÄƒ fiecare secÈ›iune:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>const express = require(&#x27;express&#x27;);
const app = express();

// 1. Definim o rutÄƒ validÄƒ de test (opÈ›ional, pentru context)
app.get(&#x27;/spells&#x27;, (req, res) =&gt; {
    // Exemplu: returnÄƒm lista de vrÄƒji disponibile
    res.json({ spells: [&quot;Lumos&quot;, &quot;Expelliarmus&quot;, &quot;Expecto Patronum&quot;] });
});

// 2. Definim o rutÄƒ care *simuleazÄƒ o eroare internÄƒ*
app.get(&#x27;/spells/error&#x27;, (req, res, next) =&gt; {
    // SimulÄƒm o eroare aruncatÄƒ (excepÈ›ie) Ã®n timpul execuÈ›iei rutei
    throw new Error(&quot;SpellFailure: incantaÈ›ia a eÈ™uat&quot;);  
    // Alternativ: next(new Error(&quot;SpellFailure&quot;));
});

// 3. Middleware &quot;catch-all&quot; pentru rutele inexistente (404 Not Found)
app.use((req, res, next) =&gt; {
    // Niciuna din rutele de mai sus nu a rÄƒspuns -&gt; resursa cerutÄƒ nu existÄƒ
    res.status(404).json({ 
        error: &quot;Not found&quot;,           // mesaj de eroare
        status: 404                   // codul de status (redundant cu cel HTTP)
    });
});

// 4. Middleware global de eroare (500 Internal Server Error)
app.use((err, req, res, next) =&gt; {
    console.error(&quot;Eroare internÄƒ:&quot;, err.message);  // AfiÈ™Äƒm eroarea Ã®n consolÄƒ (server)
    // Trimitere rÄƒspuns JSON de eroare cÄƒtre client:
    res.status(500).json({ 
        error: &quot;Internal Server Error. Something went wrong!&quot;, 
        status: 500 
    });
});</code></pre>
</div>
<p>SÄƒ analizÄƒm pe rÃ¢nd ce se Ã®ntÃ¢mplÄƒ È™i cum funcÈ›ioneazÄƒ mecanismul de tratare a erorilor Ã®n acest exemplu:</p>
<p><strong>Ruta </strong><code>/spells</code> (punctul 1) este o rutÄƒ normalÄƒ care returneazÄƒ un JSON cu o listÄƒ de vrÄƒji. Am inclus-o doar pentru context â€“ ea nu genereazÄƒ erori È™i, dacÄƒ este apelatÄƒ, va rÄƒspunde cu status 200 OK È™i lista de vrÄƒji.</p>
<p><strong>Ruta </strong><code>/spells/error</code> (punctul 2) este special conceputÄƒ pentru a arunca o eroare. CÃ¢nd aceastÄƒ rutÄƒ este apelatÄƒ, executÄƒ throw new Error(&quot;SpellFailure: incantaÈ›ia a eÈ™uat&quot;). Ãn acel moment, <em>execuÈ›ia Ã®n ruta curentÄƒ se Ã®ntrerupe</em> È™i Express va detecta excepÈ›ia. Deoarece am aruncat-o sincron Ã®n handler, Express o va prinde automat È™i va sÄƒri peste orice alt cod de rutÄƒ, trecÃ¢nd direct la cÄƒutarea unui <strong>middleware de eroare</strong> Ã®n care sÄƒ o transmitÄƒ. Practic, Express va apela urmÄƒtorul middleware care are semnÄƒtura (err, req, res, next) â€“ adicÄƒ handler-ul nostru global de eroare de la punctul 4. (NotÄƒ: dacÄƒ era o eroare asincronÄƒ â€“ de exemplu Ã®ntr-un callback sau promisiune â€“ trebuia sÄƒ folosim next(err) manual, dar Ã®n Express 5 È™i cu async/await, astfel de erori sunt propagate automat. Ãn exemplul simplu nu intrÄƒm Ã®n acest caz.)</p>
<p>OdatÄƒ ajunsÄƒ eroarea Ã®n <strong>middleware-ul global de eroare</strong> (punctul 4), codul din acesta se executÄƒ. Ãn consola serverului vom vedea mesajul de eroare (ex: &quot;Eroare internÄƒ: SpellFailure: incantaÈ›ia a eÈ™uat&quot;). Apoi serverul trimite Ã®napoi cÄƒtre client un rÄƒspuns cu status: 500 È™i corpul JSON:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>{ &quot;error&quot;: &quot;Internal Server Error. Something went wrong!&quot;, &quot;status&quot;: 500 }</code></pre>
</div>
<p>Acesta este rÄƒspunsul pe care Ã®l primeÈ™te clientul (de exemplu, dacÄƒ un elev de la Hogwarts a apelat API-ul pentru <code>/spells/error</code>). Mesajul &quot;Internal Server Error. Something went wrong!&quot; este generic; am fi putut include È™i textul erorii reale (<code>err.message</code>), dar de obicei Ã®n producÈ›ie se evitÄƒ expunerea detaliilor. Oricum, ideea este cÄƒ utilizatorul È™tie cÄƒ a survenit o eroare de server. De asemenea, dacÄƒ ne uitÄƒm la antetele HTTP, vom vedea HTTP/1.1 500 Internal Server Error ca status.</p>
<p><strong>Cum se comportÄƒ middleware-ul 404</strong> (punctul 3) Ã®n acest lanÈ›? ObservaÈ›i ordinea: l-am plasat Ã®naintea middleware-ului de eroare. Asta Ã®nseamnÄƒ cÄƒ dacÄƒ o cerere <strong>nu corespunde nici rutei </strong><code>/spells</code><strong> nici rutei </strong><code>/spells/error</code>, atunci va ajunge la middleware-ul 404. SÄƒ zicem cÄƒ cineva face o cerere GET la /spells/Invisibility (iar noi nu avem o astfel de rutÄƒ definitÄƒ). Executarea va trece prin lista de rute: nu gÄƒseÈ™te potrivire, ajunge la <code>app.use((req,res) =&gt; {...404...})</code>. Acolo noi nu apelÄƒm next(err), ci trimitem direct rÄƒspunsul 404. Astfel, cererea <strong>nu va mai ajunge</strong> la middleware-ul de eroare global, deoarece noi am Ã®nchis deja circuitul rÄƒspunzÃ¢nd la client. Clientul va primi un rÄƒspuns cu status: 404 È™i corpul:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>{ &quot;error&quot;: &quot;Not found&quot;, &quot;status&quot;: 404 }</code></pre>
</div>
<p>conform implementÄƒrii noastre. Ãn exemplul narativ, ar fi ca È™i cum un elev cere o vrajÄƒ care nu existÄƒ â€“ serverul Ã®i rÄƒspunde politicos cÄƒ nu a gÄƒsit ceea ce cautÄƒ.</p>
<p>SÄƒ verificÄƒm È™i cazul fericit: dacÄƒ cineva face GET la <code>/spells</code>, ruta existÄƒ È™i rÄƒspunde normal (status 200, JSON cu vrÄƒji). Ãn acel scenariu, nu se apeleazÄƒ deloc nici middleware-ul 404 (pentru cÄƒ am gÄƒsit ruta) nici middleware-ul de eroare (nu a apÄƒrut nicio eroare). Ele rÄƒmÃ¢n Ã®n aÈ™teptare pentru cazurile cÃ¢nd chiar este nevoie de ele.</p>
<p>Prin acest exemplu practic, vedem cum <strong>fluxul de execuÈ›ie</strong> Ã®n Express separÄƒ clar situaÈ›iile de eroare de cele normale. Middleware-urile noastre acÈ›ioneazÄƒ ca niÈ™te â€plase de siguranÈ›Äƒâ€ la finalul lanÈ›ului de procesare: unul prinde erorile neprevÄƒzute (excepÈ›ii, probleme interne) È™i altul prinde toate cererile care altfel ar rÄƒmÃ¢ne fÄƒrÄƒ rÄƒspuns (rute neimplementate). Acest mod de organizare este considerat <strong>cea mai bunÄƒ practicÄƒ</strong>. DupÄƒ cum este menÈ›ionat È™i Ã®n resursele oficiale, o aplicaÈ›ie robustÄƒ Express trebuie sÄƒ <em>catch-uiascÄƒ</em> toate rutele necontrolate È™i toate erorile neprevÄƒzute Ã®ntr-un loc central. Astfel, evitÄƒm situaÈ›ii Ã®n care serverul cade complet sau lasÄƒ clientul fÄƒrÄƒ un rÄƒspuns clar.</p>
<p>Rezumat al comportamentului Ã®n acest exemplu Hogwarts:</p>
<div class="code-block" data-lang="JavaScript">
<pre><code>GET /spells â†’ rÄƒspuns 200 OK, corp JSON cu date (fÄƒrÄƒ erori implicate).
GET /spells/error â†’ (eroare simulatÄƒ Ã®n rutÄƒ) â†’ middleware-ul global de eroare trimite rÄƒspuns 500 Internal Server Error, corp { error: &quot;...&quot;, status: 500 }.
GET /spells/unknown (sau orice altceva care nu e definit) â†’ middleware-ul 404 trimite rÄƒspuns 404 Not Found, corp { error: &quot;Not found&quot;, status: 404 }.</code></pre>
</div>
<p>Acum cÄƒ am vÄƒzut Ã®n acÈ›iune aceste mecanisme, sÄƒ trecem la concluzii È™i bune practici generale de reÈ›inut.</p>
<h2><strong>Concluzie</strong></h2>
<p>Gestionarea eficientÄƒ a erorilor Ã®ntr-o aplicaÈ›ie Express.js este la fel de vitalÄƒ ca È™i scrierea funcÈ›ionalitÄƒÈ›ii de bazÄƒ. FÄƒrÄƒ un plan clar de <strong>error handling</strong>, aplicaÈ›ia poate oferi o experienÈ›Äƒ neplÄƒcutÄƒ utilizatorilor (mesaje confuze sau lipsÄƒ de rÄƒspuns) È™i poate Ã®ngreuna munca dezvoltatorilor (debugging dificil, lipsa log-urilor centralizate). AÈ™a cum am arÄƒtat prin analogia Hogwarts, chiar È™i cei mai iscusiÈ›i vrÄƒjitori (developerii) au nevoie de o plasÄƒ de siguranÈ›Äƒ pentru vrÄƒjile care dau greÈ™ (erorile).</p>
<p>RecapitulÃ¢nd principalele idei È™i <strong>bune practici</strong>:</p>
<p><strong>Centralizarea tratÄƒrii erorilor</strong> â€“ FolosiÈ›i un middleware global de eroare ((err, req, res, next)) pentru a prinde toate excepÈ›iile neanticipate. Acesta previne oprirea bruscÄƒ a serverului È™i permite trimiterea unui rÄƒspuns controlat cÄƒtre client. LogaÈ›i aici detaliile erorii (ideal, Ã®n mod silenÈ›ios pe server sau Ã®ntr-un serviciu de monitorizare) È™i trimiteÈ›i clientului un mesaj generic sau prietenos. Nu expuneÈ›i informaÈ›ii sensibile Ã®n rÄƒspuns.</p>
<p><strong>Tratamentul rutelor nevalide (404)</strong> â€“ AsiguraÈ›i-vÄƒ cÄƒ ultima ruta din aplicaÈ›ie este una de tip <em>catch-all</em> care returneazÄƒ <strong>404 Not Found</strong> pentru orice cerere care nu È™i-a gÄƒsit corespondent. Astfel, utilizatorii API-ului vor primi un rÄƒspuns clar cÃ¢nd greÈ™esc adresa, iar aplicaÈ›ia nu va lÄƒsa conexiuni deschise fÄƒrÄƒ rÄƒspuns. PuteÈ›i personaliza mesajul 404 pentru a oferi eventual instrucÈ›iuni (de ex. &quot;URL greÈ™it, verificaÈ›i documentaÈ›ia&quot;).</p>
<p><strong>Separarea tipurilor de erori</strong> â€“ Este esenÈ›ial sÄƒ faceÈ›i diferenÈ›a Ã®ntre erorile care reprezintÄƒ <em>probleme ale clientului</em> È™i cele care indicÄƒ <em>probleme interne de server</em>. Ãn termeni de cod de status HTTP:</p>
<p><strong>4xx (Client Errors)</strong> â€“ Apar cÃ¢nd cererea are o problemÄƒ. De exemplu, <strong>400 Bad Request</strong> indicÄƒ date de intrare invalide sau format greÈ™it al cererii (echivalent cu a spune cÄƒ utilizatorul a greÈ™it incantaÈ›ia ğŸ’¬). <strong>404 Not Found</strong> semnaleazÄƒ cÄƒ resursa cerutÄƒ nu existÄƒ (utilizatorul a greÈ™it adresa, ca Ã®n cazul unei camere inexistente la Hogwarts).</p>
<p><strong>5xx (Server Errors)</strong> â€“ Apar cÃ¢nd serverul nu poate procesa corect o cerere din cauza unor erori interne sau situaÈ›ii neaÈ™teptate. <strong>500 Internal Server Error</strong> este cel mai generic cod, indicÃ¢nd cÄƒ â€œceva a mers prostâ€ pe server (un experiment al profesorului a eÈ™uat spectaculos ğŸ§¨). Alte coduri 5xx existÄƒ pentru situaÈ›ii mai specifice, dar 500 acoperÄƒ majoritatea cazurilor de excepÈ›ii neprevÄƒzute.</p>
<p>Ãn practica de dezvoltare, <strong>erorile intenÈ›ionate vs. neintenÈ›ionate</strong> se trateazÄƒ diferit: dacÄƒ È™tiÈ›i cÄƒ o anumitÄƒ condiÈ›ie de eroare poate surveni (de ex., utilizatorul nu trimite un parametru obligatoriu), atunci ar trebui sÄƒ trimiteÈ›i un <strong>4xx</strong> adecvat (ex. 400 Bad Request cu un mesaj despre parametru lipsÄƒ), Ã®n loc sÄƒ lÄƒsaÈ›i aplicaÈ›ia sÄƒ arunce o excepÈ›ie genericÄƒ de 500. RezervaÈ›i codurile <code>500</code> doar pentru acele situaÈ›ii pe care nu le-aÈ›i putut preveni sau care reprezintÄƒ erori Ã®n cod. Astfel, clienÈ›ii aplicaÈ›iei pot face diferenÈ›a: un 400 sau 404 indicÄƒ o eroare de input sau de adresÄƒ ce poate fi corectatÄƒ de ei, pe cÃ¢nd un 500 indicÄƒ o problemÄƒ pe server care nu È›ine de acÈ›iunile lor.</p>
<p><strong>Mediul de producÈ›ie vs. dezvoltare</strong> â€“ AsiguraÈ›i-vÄƒ cÄƒ aveÈ›i un comportament diferit al handler-elor de erori Ã®n funcÈ›ie de mediu. Ãn dezvoltare, este acceptabil sÄƒ afiÈ™aÈ›i mai multe informaÈ›ii (poate chiar <em>stack trace</em>-ul sau <code>err.message</code>) pentru a debuga rapid. Ãn producÈ›ie, limitaÈ›i-vÄƒ la mesaje generale È™i logaÈ›i detaliile Ã®n privat. Express Ã®n sine ascunde stack trace-ul Ã®n mod producÈ›ie dacÄƒ folosiÈ›i handler-ul implicit, dar dacÄƒ aveÈ›i unul personalizat, responsabilitatea vÄƒ aparÈ›ine. DupÄƒ cum subliniazÄƒ È™i Kosisochukwu (2024), nu trimiteÈ›i niciodatÄƒ <em>stack</em>-ul complet cÄƒtre client, deoarece poate divulga informaÈ›ii sensibile despre aplicaÈ›ie.</p>
<p><strong>PlanificaÈ›i oprirea graÈ›ioasÄƒ</strong> â€“ DeÈ™i nu a fost subiectul central al lecÈ›iei, meritÄƒ menÈ›ionat cÄƒ pentru erori catastrofale (ex. necapturate, cum ar fi respingerea necontrolatÄƒ a unei promisiuni sau o excepÈ›ie nesurprinsÄƒ la nivel global), ar trebui sÄƒ aveÈ›i mecanisme de a <em>Ã®nchide graÈ›ios serverul</em> È™i de a reporni aplicaÈ›ia. Acest aspect È›ine de fiabilitatea Ã®n producÈ›ie â€“ unele erori nu pot fi recuperate, iar serverul trebuie repornit Ã®ntr-o stare curatÄƒ.</p>
<p>Ãn Ã®ncheiere, am demonstrat cum <strong>o strategie robustÄƒ de gestionare </strong><strong>a</strong><strong> erorilor</strong> Ã®mbunÄƒtÄƒÈ›eÈ™te calitatea È™i siguranÈ›a aplicaÈ›iilor Express. La fel ca Ã®n lumea Hogwarts, unde fiecare vrÄƒjitor È™tie cÄƒ trebuie sÄƒ aibÄƒ un plan de rezervÄƒ cÃ¢nd lucrurile o iau razna, È™i Ã®n programare trebuie sÄƒ anticipÄƒm È™i sÄƒ controlÄƒm modul Ã®n care aplicaÈ›ia reacÈ›ioneazÄƒ la probleme. Abordarea centralizatÄƒ cu middleware-uri de eroare È™i 404 ne permite sÄƒ menÈ›inem controlul asupra situaÈ›iilor neprevÄƒzute, oferind totodatÄƒ utilizatorilor mesaje utile. O aplicaÈ›ie Express bine construitÄƒ nu va lÄƒsa erorile la voia Ã®ntÃ¢mplÄƒrii: va <strong>Ã®ncapsula</strong> haosul Ã®n mesaje clare È™i coduri HTTP corecte, asigurÃ¢nd o experienÈ›Äƒ predictibilÄƒ pentru client È™i un proces de debug mai uÈ™or pentru dezvoltator.</p>
<p><strong>Ãn</strong><strong> final, </strong><strong>lecÈ›ia</strong><strong> de </strong><strong>astÄƒzi</strong><strong> </strong><strong>este</strong><strong> </strong><strong>aceasta</strong>: trateazÄƒ-È›i erorile cu la fel de multÄƒ grijÄƒ pe cÃ¢t Ã®È›i tratezi funcÈ›ionalitatea principalÄƒ. Cu un pic de pregÄƒtire È™i folosind mecanismele oferite de Express, chiar È™i cele mai â€œneastÃ¢mpÄƒrateâ€ erori pot fi È›inute sub control!</p>
<div class="references">
<h2><strong>ReferinÈ›e</strong></h2>
<p>MDN Web Docs. (2025, October 30). <em>HTTP response status codes</em>. Mozilla. Retrieved November 13, 2025, from https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status</p>
<p>Express.js. (n.d.). <em>FAQ: How do I handle 404 responses?</em> Express.js Official Documentation. Retrieved November 13, 2025, from https://expressjs.com/en/starter/faq.html</p>
<p>Express.js. (n.d.). <em>Guide: Error handling</em>. Express.js Official Documentation. Retrieved November 13, 2025, from https://expressjs.com/en/guide/error-handling.html</p>
<p>Kosisochukwu, M. (2024, June 26). <em>Express.js Error Handling 101</em>. ButterCMS. Retrieved November 13, 2025, from https://buttercms.com/blog/express-js-error-handling/</p>
<p>CodeSignal. (2025). <em>Handling 404 and 500 Errors in Express.js</em>. CodeSignal Learn. Retrieved November 13, 2025, from https://codesignal.com/learn/courses/first-steps-into-back-end-engineering-with-expressjs/lessons/handling-404-and-500-errors-in-expressjs</p>
<h3><strong>â€œGrayâ€</strong></h3>
<p>   HTTP response status codes - HTTP | MDN<br>
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status</a></p>
<p> Handling 404 and 500 Errors in Express.js | CodeSignal Learn<br>
<a href="https://codesignal.com/learn/courses/first-steps-into-back-end-engineering-with-expressjs/lessons/handling-404-and-500-errors-in-expressjs">https://codesignal.com/learn/courses/first-steps-into-back-end-engineering-with-expressjs/lessons/handling-404-and-500-errors-in-expressjs</a></p>
<p>      Express.js Error Handling 101 | ButterCMS<br>
<a href="https://buttercms.com/blog/express-js-error-handling/">https://buttercms.com/blog/express-js-error-handling/</a></p>
<p>     Express error handling<br>
<a href="https://expressjs.com/en/guide/error-handling.html">https://expressjs.com/en/guide/error-handling.html</a></p>
<p>   Express FAQ<br>
<a href="https://expressjs.com/en/starter/faq.html">https://expressjs.com/en/starter/faq.html</a></p>
</div>

    </div>
</body>
</html>